###Реализация структуры очереди на основе циклического массива.
#####Группа 2017-04-1

*Следует учесть, что данная реализация имеет только учебный характер
и никак не подходит для боевых условий!*

Ключевые моменты:
* Очередь реализует интерфейс `java.util.Queue`
* Очередь неограничена
* Очередь FIFO
* Очередь, согласно своему интерфейсу, не разрешает помещать `null`
* Очередь использует циклический массив: так как FIFO, то после извлечения элемента
 высвобождается `начало` массива, и часть можно переиспользовать как `конец` при
 перезаполнении 
* Очередь не потокобезопасна, есть стандартная проверка на запрет изменений очереди
 при итерировании по ней. Если такие изменения выявлены, то выбрасывается стандартный
 `java.util.ConcurrentModificationException`. Реализация итератора схожа с реализацией в 
 `java.util.AbstractList` с некоторыми изменениями
* На операциях, которые не относятся к интерфейсу `java.util.Queue`, очередь ведёт себя 
как и другие стандартные коллекции. Например метод `boolean remove(Object o)` удалит
из представления очереди *любой* элемент `o` безотносительно к FIFO, если такой элемент есть.
Но для операций `Object[] toArray()`, `Object[] toArray(T[] a)`, `Iterator<E> iterator()` гарантируется
 порядок, обусловленный семантикой FIFO
* При удалении элемента из очереди, в ущерб размеру памяти, но в пользу скорости работы, размер внутреннего
массива не меняется, а только обнуляется ссылка удаленного объекта, даже если удаление было из середины
массива. Для этого поддерживается битовая маска всех элементов массива
* При расширении массива текущий массив сжимается физически: `размер нового массива =
2 * (размер предыдущего массива - количество элементов, помеченных как удалённые)`. Расширение происходит,
когда в массиве `зазор` между `началом` и `концом` уменьшается до 1
* Используется дефолтный `spliterator` - нет никаких оптимизаций для параллельной обработки 
через `Stream API` 

#### Автор 
Anvar Kiekbaev (Анвар Киекбаев)

a.kiekbaev@chepiov.org


